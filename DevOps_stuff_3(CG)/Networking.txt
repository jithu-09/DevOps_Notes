Networking

+ DNS: Domain Name System(BTS system)
  -> Gets Domain name looks for corresponding IP Address and and connects your computer to that server and loads the website.
  Step-by-Step Process:
  - You enter www.example.com in your browser.
  = Your computer asks the DNS resolver for the IP address.
  - The resolver checks its cache or queries other DNS servers.
  - Once it finds the matching IP, it returns it to your browser.
  = Your browser connects to the IP and loads the website.

+ Forward prxy vs Reverse prxy
  -> Aspect	                 Forward Proxy	                      Reverse Proxy
     Position	         Between client and the internet      Between internet and the server
     Who it represents	   Acts on behalf of the client	        Acts on behalf of the server
     Use Cases	                Anonymize clients	

-  Client → Forward Proxy → Google | User → Reverse Proxy → Internal Web Server |
- fwd prxy: used by clients to access ext servers, The target server only sees the proxy, not the real client.
- rvrs prxy: sits in front of a group of servers and routes client requests to them. Clients thinks talking to server but doing so with prxy.
  Used for load balancing, security, and SSL offloading.
- exs: Forward Proxy:
       A school uses a proxy server to prevent students from accessing YouTube.
       Reverse Proxy:
       A company uses NGINX as a reverse proxy to distribute requests to multiple backend services (e.g., /api, /auth, /app).


+ App slowness: App slowness can come from frontend, backend, DB, infrastructure, or network. Use a systematic layer-by-layer approach to isolate and fix the issue. Focus first on scope, then verify each component with logs, metrics, and tools.

+ DNS Resolution: If curl http://<IP> works but curl http://example.com fails, the issue is most likely DNS-related.
  -> run nslookup example.com, dig example.com, fails => DNS issue
  -> server misconfig: Check /etc/resolv.conf (Linux) to ensure a valid DNS nameserver (e.g., 8.8.8.8) is present.
  -> Firewall or Network Blocking DNS: Port 53(used by dns) could be blocked, test with: dig example.com @8.8.8.8
  -> Domain Doesn't Exist or Typo: whois example.com - Confirm the domain name is correct and publicly registered.
  -> Host File Override: sudo /etc/hosts - Remove or correct any conflicting/ incorrect entries.
  -> If the domain is internal (e.g., myapp.internal.local): Make sure you're connected to the appropriate VPN or internal network.

  #How to Fix
  - Add a DNS server like Google DNS: echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf > /dev/null
  - Or temporarily test with: curl --resolve example.com:80:<IP> http://example.com

+ 502 Bad Gateway: Means that a gateway or proxy server (like NGINX, HAProxy, or AWS ELB) got an invalid response from the upstream server (like an app server or container)
  -> A 502 error is returned when the reverse proxy or load balancer is unable to reach the backend service or gets a malformed response. Check service      status, logs, port connectivity, timeouts, and config mismatches to fix it.

  causes:
  - Backend is down: find status - systemctl status your-app
  - NGINX is trying to proxy to the wrong port or host: Check nginx.conf or site config: proxy_pass http://localhost:5000;
  - Backend is Too Slow to respond/ Times Out: Adjust timeouts- proxy_read_timeout 60s;
  - Firewall or Security Group Blocking Backend port (e.g., 3000, 5000): check using - telnet or nc -zv localhost 5000
  - Incorrect SSL Termination: NGINX expects HTTP but backend speaks HTTPS (or vice versa).
  - App logs show OOMKilled, panic, or crashed out: check logs- journalctl -u your-app, docker logs your-container

  #Troubleshoot:
  - check nginx(proxy) logs: tail -f /var/log/nginx/error.log
  - Restart app and nginx: systemctl restart your-app, systemctl restart nginx
  - Check App Health Endpoint: curl http://localhost:5000/health
  - to simulate 502: systemlctl stop your-app

+ 0.0.0.0 vs 127.0.0.1:
  - 127.0.0.1: Loopback address (localhost), Used by your computer to talk to itself, Traffic never leaves your machine, for testing, development, or inter-process communication. Ex: curl http://127.0.0.1:8080 - This calls a server running on your local machine only.
  - 0.0.0.0: All IPv4 addresses on the local machine, Used commonly by servers to listen on all network interfaces to receive traffic from any ip. You can curl it, but svcs use it to bind. Ex: python3 -m http.server --bind 0.0.0.0 => This will make the web server available to other devices on the network

# Use 127.0.0.1 when you want to keep traffic inside your machine. Use 0.0.0.0 when you want your server or service to accept traffic from anyone, on any IP address your machine has.

Let’s say your machine has: Local IP: 192.168.1.100, You run a web server on port 8080
Binding Address	       Accessible from same machine?	Accessible from other machines?
127.0.0.1			✅ Yes	                             ❌ No
0.0.0.0				✅ Yes	                             ✅ Yes
192.168.1.100	                ✅ Yes	                             ✅ Yes